<?php

/**
 * @file
 * Helper functions for Vortex tooling scripts.
 */

declare(strict_types=1);

namespace DrevOps\VortexTooling;

load_dotenv(['.env', '.env.local']);

/**
 * Check if current script has an override and execute it if found.
 *
 * Call this at the start of your script to allow it to be overridden.
 *
 * @param string $name
 *   Name of current script.
 */
function execute_override(string $name): void {
  $dir = getenv('VORTEX_TOOLING_CUSTOM_DIR');
  if ($dir) {
    $path = $dir . DIRECTORY_SEPARATOR . $name;
    if (file_exists($path) && is_executable($path)) {
      passthru(sprintf('"%s"', $path), $exit_code);
      exit($exit_code);
    }
  }
}

/**
 * Load environment variables from .env and .env.local files.
 *
 * @param array<int,string> $env_files
 *   Array of environment file paths to load.
 */
function load_dotenv(array $env_files = ['.env']): void {
  foreach ($env_files as $env_file) {
    if (file_exists($env_file)) {
      $lines = file($env_file, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES);

      if ($lines === FALSE) {
        continue;
      }

      foreach ($lines as $line) {
        // Skip comments.
        if (str_starts_with(trim($line), '#')) {
          continue;
        }

        // Parse KEY=VALUE format.
        if (str_contains($line, '=')) {
          [$key, $value] = explode('=', $line, 2);
          $key = trim($key);
          $value = trim($value);

          // Remove quotes if present.
          if ((str_starts_with($value, '"') && str_ends_with($value, '"')) ||
            (str_starts_with($value, "'") && str_ends_with($value, "'"))) {
            $value = substr($value, 1, -1);
          }

          putenv(sprintf('%s=%s', $key, $value));
        }
      }
    }
  }
}

/**
 * Output a note message.
 *
 * @param string $format
 *   Format string for sprintf().
 * @param bool|float|int|string|null ...$args
 *   Arguments for sprintf().
 */
function note(string $format, ...$args): void {
  echo sprintf('       %s%s', sprintf($format, ...$args), PHP_EOL);
}

/**
 * Output a task message.
 *
 * @param string $format
 *   Format string for sprintf().
 * @param bool|float|int|string|null ...$args
 *   Arguments for sprintf().
 */
function task(string $format, ...$args): void {
  echo _supports_color() ?
    "\033[34m[TASK] " . sprintf($format, ...$args) . "\033[0m\n" :
    sprintf('[TASK] %s%s', sprintf($format, ...$args), PHP_EOL);
}

/**
 * Output an info message.
 *
 * @param string $format
 *   Format string for sprintf().
 * @param bool|float|int|string|null ...$args
 *   Arguments for sprintf().
 */
function info(string $format, ...$args): void {
  echo _supports_color() ?
    "\033[36m[INFO] " . sprintf($format, ...$args) . "\033[0m\n" :
    sprintf('[INFO] %s%s', sprintf($format, ...$args), PHP_EOL);
}

/**
 * Output a success message.
 *
 * @param string $format
 *   Format string for sprintf().
 * @param bool|float|int|string|null ...$args
 *   Arguments for sprintf().
 */
function pass(string $format, ...$args): void {
  echo _supports_color() ?
    "\033[32m[ OK ] " . sprintf($format, ...$args) . "\033[0m\n" :
    sprintf('[ OK ] %s%s', sprintf($format, ...$args), PHP_EOL);
}

/**
 * Output a failure message and do not exit.
 *
 * @param string $format
 *   Format string for sprintf().
 * @param bool|float|int|string|null ...$args
 *   Arguments for sprintf().
 */
function fail_no_exit(string $format, ...$args): void {
  echo _supports_color() ?
    "\033[31m[FAIL] " . sprintf($format, ...$args) . "\033[0m\n" :
    sprintf('[FAIL] %s%s', sprintf($format, ...$args), PHP_EOL);
}

/**
 * Output a failure message.
 *
 * @param string $format
 *   Format string for sprintf().
 * @param bool|float|int|string|null ...$args
 *   Arguments for sprintf().
 */
function fail(string $format, ...$args): void {
  fail_no_exit($format, ...$args);
  exit(1);
}

/**
 * Require an environment variable to be set.
 *
 * @param string $name
 *   Environment variable name.
 * @param string|null $message
 *   Custom error message (optional).
 */
function validate_variable(string $name, ?string $message = NULL): void {
  $value = getenv($name);
  if ($value === FALSE || $value === '') {
    fail($message ?? sprintf('Missing required value for variable %s', $name));
  }
}

/**
 * Require a command to be available.
 *
 * @param string $command
 *   Command name.
 */
function validate_command(string $command): void {
  exec(sprintf('command -v %s 2>/dev/null', $command), $output, $code);
  if ($code !== 0) {
    fail(sprintf("Command '%s' is not available", $command));
  }
}

/**
 * Replace tokens in a string.
 *
 * @param string $template
 *   Template string with tokens like %project%, %label%, etc.
 * @param array<string,string> $replacements
 *   Array of token => value pairs.
 *
 * @return string
 *   String with tokens replaced.
 */
function replace_tokens(string $template, array $replacements): string {
  $search = [];
  $replace = [];

  foreach ($replacements as $token => $value) {
    $search[] = sprintf('%%%s%%', $token);
    $replace[] = $value;
  }

  return str_replace($search, $replace, $template);
}

/**
 * Check if debug mode is enabled.
 */
function is_debug(): bool {
  return getenv('VORTEX_DEBUG') === '1';
}

/**
 * Check if terminal supports colors.
 */
function _supports_color(): bool {
  return getenv('TERM') === 'dumb' || getenv('TERM') === FALSE ? FALSE : function_exists('posix_isatty') && @posix_isatty(STDOUT);
}

/**
 * Perform a cURL GET request.
 *
 * @param string $url
 *   URL to request.
 * @param array<int, string> $headers
 *   Array of HTTP headers.
 * @param int $timeout
 *   Request timeout in seconds.
 *
 * @return array{ok: bool, status: int, body: string|false, error: string|null, info: array<string, mixed>}
 *   Array with keys:
 *   - ok: TRUE if request was successful (HTTP < 400), FALSE otherwise
 *   - status: HTTP status code
 *   - body: Response body
 *   - error: cURL error message if any
 *   - info: cURL info array
 */
function curl_get(string $url, array $headers = [], int $timeout = 10): array {
  return curl_request($url, [
    'method' => 'GET',
    'headers' => $headers,
    'timeout' => $timeout,
  ]);
}

/**
 * Perform a cURL POST request.
 *
 * @param string $url
 *   URL to request.
 * @param mixed $body
 *   Request body.
 * @param array<int, string> $headers
 *   Array of HTTP headers.
 * @param int $timeout
 *   Request timeout in seconds.
 *
 * @return array{ok: bool, status: int, body: string|false, error: string|null, info: array<string, mixed>}
 *   Array with keys:
 *   - ok: TRUE if request was successful (HTTP < 400), FALSE otherwise
 *   - status: HTTP status code
 *   - body: Response body
 *   - error: cURL error message if any
 *   - info: cURL info array
 */
function curl_post(string $url, $body = NULL, array $headers = [], int $timeout = 10): array {
  return curl_request($url, [
    'method' => 'POST',
    'body' => $body,
    'headers' => $headers,
    'timeout' => $timeout,
  ]);
}

/**
 * Perform a cURL request.
 *
 * @param string $url
 *   URL to request.
 * @param array{method?: string, headers?: array<int, string>, body?: mixed, timeout?: int} $options
 *   Array of options:
 *   - method: HTTP method (GET, POST, etc.)
 *   - headers: Array of HTTP headers
 *   - body: Request body
 *   - timeout: Request timeout in seconds.
 *
 * @return array{ok: bool, status: int, body: string|false, error: string|null, info: array<string, mixed>}
 *   Array with keys:
 *   - ok: TRUE if request was successful (HTTP < 400), FALSE otherwise
 *   - status: HTTP status code
 *   - body: Response body
 *   - error: cURL error message if any
 *   - info: cURL info array
 */
function curl_request(string $url, array $options = []): array {
  if (!function_exists('curl_init')) {
    fail('curl extension is not available.');
    exit(1);
  }

  $ch = curl_init($url);

  /** @var array<int, mixed> $opts */
  $opts = [
    CURLOPT_RETURNTRANSFER => TRUE,
    CURLOPT_FOLLOWLOCATION => TRUE,
    CURLOPT_TIMEOUT => $options['timeout'] ?? 10,
  ];

  if (isset($options['method'])) {
    $opts[CURLOPT_CUSTOMREQUEST] = strtoupper((string) $options['method']);
  }

  if (isset($options['headers'])) {
    $opts[CURLOPT_HTTPHEADER] = $options['headers'];
  }

  if (isset($options['body'])) {
    $opts[CURLOPT_POSTFIELDS] = $options['body'];
  }

  curl_setopt_array($ch, $opts);

  // With CURLOPT_RETURNTRANSFER, curl_exec returns string|false.
  /** @var string|false $body */
  $body = curl_exec($ch);
  $error = curl_errno($ch) ? curl_error($ch) : NULL;
  $info = curl_getinfo($ch);

  curl_close($ch);

  // Handle curl_getinfo failure.
  if ($info === FALSE) {
    $info = ['http_code' => 0];
  }

  return [
    'ok' => !$error && ($info['http_code'] < 400),
    'status' => $info['http_code'],
    'body' => $body,
    'error' => $error,
    'info' => $info,
  ];
}
